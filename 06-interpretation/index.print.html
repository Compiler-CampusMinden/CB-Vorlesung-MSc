<!DOCTYPE html>
<html lang="de-DE" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.135.0">
    <meta name="generator" content="Relearn 6.4.1">
    <meta name="description" content="Ein Interpreter erzeugt keinen Code, sondern führt Source-Code (interaktiv) aus. Die einfachste Möglichkeit ist der Einsatz von attributierten Grammatiken, wo der Code bereits beim Parsen ausgeführt wird (&#34;syntaxgesteuerte Interpretation&#34;). Mehr Möglichkeiten hat man dagegen bei der Traversierung des AST, beispielsweise mit dem Visitor-Pattern. Auch die Abarbeitung von Bytecode in einer Virtuellen Maschine (VM) zählt zur Interpretation.
(Register- und Stack-basierte Interpreter betrachten wir im Rahmen der Veranstaltung aktuell nicht.)
Syntaxgesteuerte Interpreter AST-basierte Interpreter: Basics AST-basierte Interpreter: Funktionen und Klassen">
    <meta name="author" content="">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Interpreter">
    <meta name="twitter:description" content="Ein Interpreter erzeugt keinen Code, sondern führt Source-Code (interaktiv) aus. Die einfachste Möglichkeit ist der Einsatz von attributierten Grammatiken, wo der Code bereits beim Parsen ausgeführt wird (&#34;syntaxgesteuerte Interpretation&#34;). Mehr Möglichkeiten hat man dagegen bei der Traversierung des AST, beispielsweise mit dem Visitor-Pattern. Auch die Abarbeitung von Bytecode in einer Virtuellen Maschine (VM) zählt zur Interpretation.
(Register- und Stack-basierte Interpreter betrachten wir im Rahmen der Veranstaltung aktuell nicht.)
Syntaxgesteuerte Interpreter AST-basierte Interpreter: Basics AST-basierte Interpreter: Funktionen und Klassen">
    <meta property="og:url" content="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1603207/06-interpretation.html">
    <meta property="og:title" content="Interpreter">
    <meta property="og:description" content="Ein Interpreter erzeugt keinen Code, sondern führt Source-Code (interaktiv) aus. Die einfachste Möglichkeit ist der Einsatz von attributierten Grammatiken, wo der Code bereits beim Parsen ausgeführt wird (&#34;syntaxgesteuerte Interpretation&#34;). Mehr Möglichkeiten hat man dagegen bei der Traversierung des AST, beispielsweise mit dem Visitor-Pattern. Auch die Abarbeitung von Bytecode in einer Virtuellen Maschine (VM) zählt zur Interpretation.
(Register- und Stack-basierte Interpreter betrachten wir im Rahmen der Veranstaltung aktuell nicht.)
Syntaxgesteuerte Interpreter AST-basierte Interpreter: Basics AST-basierte Interpreter: Funktionen und Klassen">
    <meta property="og:locale" content="de_DE">
    <meta property="og:type" content="website">
    <meta itemprop="name" content="Interpreter">
    <meta itemprop="description" content="Ein Interpreter erzeugt keinen Code, sondern führt Source-Code (interaktiv) aus. Die einfachste Möglichkeit ist der Einsatz von attributierten Grammatiken, wo der Code bereits beim Parsen ausgeführt wird (&#34;syntaxgesteuerte Interpretation&#34;). Mehr Möglichkeiten hat man dagegen bei der Traversierung des AST, beispielsweise mit dem Visitor-Pattern. Auch die Abarbeitung von Bytecode in einer Virtuellen Maschine (VM) zählt zur Interpretation.
(Register- und Stack-basierte Interpreter betrachten wir im Rahmen der Veranstaltung aktuell nicht.)
Syntaxgesteuerte Interpreter AST-basierte Interpreter: Basics AST-basierte Interpreter: Funktionen und Klassen">
    <meta itemprop="wordCount" content="78">
    <title>Interpreter</title>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1603207/06-interpretation.html" rel="canonical" type="text/html" title="Interpreter">

    

    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/images/logo.png?1736351933" rel="icon" type="image/png">

    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/css/fontawesome-all.min.css?1736351933" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/css/fontawesome-all.min.css?1736351933" rel="stylesheet"></noscript>
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/css/nucleus.css?1736351933" rel="stylesheet">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/css/auto-complete.css?1736351933" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/css/auto-complete.css?1736351933" rel="stylesheet"></noscript>
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/css/perfect-scrollbar.min.css?1736351933" rel="stylesheet">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/css/fonts.css?1736351933" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/css/fonts.css?1736351933" rel="stylesheet"></noscript>
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/css/theme.css?1736351933" rel="stylesheet">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/css/theme-auto.css?1736351933" rel="stylesheet" id="R-variant-style">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/css/chroma-auto.css?1736351933" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/css/variant.css?1736351933" rel="stylesheet">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/css/print.css?1736351933" rel="stylesheet" media="print">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/css/format-print.css?1736351933" rel="stylesheet">
    <script src="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/js/variant.js?1736351933"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='.';
      window.relearn.relBaseUri='..\/..\/..\/..\/..';
      window.relearn.absBaseUri='https:\/\/www.hsbi.de\/elearning\/data\/FH-Bielefeld\/lm_data\/lm_1603207';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.index_js_url="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/index.search.js?1736351933";
      // variant stuff
      window.variants && variants.init( [ 'auto', 'zen-light', 'zen-dark', 'relearn-bright', 'relearn-light', 'relearn-dark' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script><style type="text/css">

 
.center {
    align-content: center;
    text-align: center;
    margin: auto;
}
.alert {
    color: #ff3333;
}
.bsp {
    padding: 0.05cm;
    border-width: 0.05cm;
    border-style: solid;
    border-color: #ddd;
    background-color: #ddd;
    border-radius: 25px;
    float: right;
}
.cbox {
    padding: 0.2cm;
    border-width: 0.1cm;
    border-style: solid;
    border-color: #4070a0;
    background-color: #f2f2f2;
    margin: auto;
    width: 60%;
    text-align: center;
    overflow: auto;
}
.blueArrow {
    color: #4070a0;
    font-family: "Courier New", "Courier", monospace;
    font-weight: bold;
}
.origin {
    background-color: #ededed;
    font-size: 0.8em;
}
.showme {
    background-color: #ededed;
    font-size: 0.8em;
}


 
.tldr {
    background: #dbe4ed;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.recap {
    
    
   margin: 4px 0px 26px 0px;
}
.bib {
    background: #dbe4ed;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.outcomes {
    background: #d9e9d5;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.quizzes {
    background: #d9e9d5;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.challenges {
    background: #ebe4d6;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.assignments {
    background: #ebe4d6;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
h1.tldr, h1.recap, h1.bib, h1.outcomes, h1.quizzes, h1.challenges, h1.assignments {
    padding: 0px;
}


 
.noJsAlert {
    padding: 20px;
    background-color: #f44336;  
    color: white;
    margin-bottom: 15px;
}


 
.embed-video-player {
    position: relative;
    padding-bottom: 56%;
    height: 0;
    overflow: hidden;
}
.youtube-player {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border:0;
}


 
#header-wrapper {
    padding:0.6rem;
}


 
#shortcuts {
    padding-top: 2.0rem;
}


 
#chapter p {
    text-align: left;
}


 
figcaption h4 {
    margin-top:-2.5rem;
}
.border1 {
    border:1px solid black;
}

 
td ul, td ol {
    margin: 0 0 1rem 0.5rem;
    padding: 0 0 0 0.5rem;
}

 
h1 { font-size:2.8rem !important;}
h2 { font-size:2.2rem; margin:1.2rem 0}
h3 { font-size:1.9rem; text-align:left !important; font-weight:400 !important;}
h4 { font-size:1.6rem}
h5 { font-size:1.3rem}
h6 { font-size:1rem}

h2 {
    width:100% !important;
    border-bottom:1px solid #5e5e5e !important;
    padding-bottom: 2px;
}
.tldr h2, .recap h2, .bib h2, .outcomes h2, .quizzes h2, .challenges h2, .assignments h2 {
    margin:0.5rem 0
}

.btn-crossreference, .btn-crossreference:hover {
    cursor: initial;
}

</style>

  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/06-interpretation.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
          </div>
          <span class="topbar-breadcrumbs highlightable">
            Interpreter
          </span>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>

<h1 id="interpreter">Interpreter</h1>

<p>Ein Interpreter erzeugt keinen Code, sondern führt Source-Code (interaktiv) aus. Die einfachste
Möglichkeit ist der Einsatz von attributierten Grammatiken, wo der Code bereits beim Parsen
ausgeführt wird (&quot;syntaxgesteuerte Interpretation&quot;). Mehr Möglichkeiten hat man dagegen bei der
Traversierung des AST, beispielsweise mit dem Visitor-Pattern. Auch die Abarbeitung von Bytecode
in einer Virtuellen Maschine (VM) zählt zur Interpretation.</p>
<p>(Register- und Stack-basierte Interpreter betrachten wir im Rahmen der Veranstaltung aktuell nicht.)</p>
<ul class="children children-li children-sort-">
  <li><a href="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/06-interpretation/syntaxdriven.html">Syntaxgesteuerte Interpreter</a></li>
  <li><a href="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/06-interpretation/astdriven-part1.html">AST-basierte Interpreter: Basics</a></li>
  <li><a href="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/06-interpretation/astdriven-part2.html">AST-basierte Interpreter: Funktionen und Klassen</a></li>
</ul>

            <footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin-left: 4rem; margin-right: 4rem; margin-top: 6rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Interpreter</h1>
<article class="default">
<h1>Syntaxgesteuerte Interpreter</h1>



    



    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-graduation-cap"></i> TL;DR
  </div>
  <div class="box-content">
<p>Zur Einordnung noch einmal die bisher betrachteten Phasen und die jeweiligen Ergebnisse:</p>
<p><a href="#R-image-2bf9e658b722369e3e362a99c88a5c96" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="https://raw.githubusercontent.com/Compiler-CampusMinden/CB-Vorlesung-Master/master/lecture/06-interpretation/images/architektur_cb.png?width=auto&height=auto" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2bf9e658b722369e3e362a99c88a5c96"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="https://raw.githubusercontent.com/Compiler-CampusMinden/CB-Vorlesung-Master/master/lecture/06-interpretation/images/architektur_cb.png?width=auto&height=auto"></a></p>
<table>
  <thead>
      <tr>
          <th style="text-align: left"></th>
          <th style="text-align: left">Phase</th>
          <th style="text-align: left">Ergebnis</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">0</td>
          <td style="text-align: left">Lexer/Parser</td>
          <td style="text-align: left">AST</td>
      </tr>
      <tr>
          <td style="text-align: left">1</td>
          <td style="text-align: left">Semantische Analyse, Def-Phase</td>
          <td style="text-align: left">Symboltabelle (Definitionen), Verknüpfung Scopes mit AST-Knoten</td>
      </tr>
      <tr>
          <td style="text-align: left">2</td>
          <td style="text-align: left">Semantische Analyse, Ref-Phase</td>
          <td style="text-align: left">Prüfung auf nicht definierte Referenzen</td>
      </tr>
      <tr>
          <td style="text-align: left">3</td>
          <td style="text-align: left">Interpreter</td>
          <td style="text-align: left">Abarbeitung, Nutzung von AST und Symboltabelle</td>
      </tr>
  </tbody>
</table>
<p>Das Erzeugen der Symboltabelle wird häufig in zwei Phasen aufgeteilt: Zunächst
werden die Definitionen abgearbeitet und in der zweiten Phase wird noch einmal
über den AST iteriert und die Referenzen werden geprüft. Dies hat den Vorteil,
dass man mit Vorwärtsreferenzen arbeiten kann ...</p>
<p>Für die semantische Analyse kann man gut mit Listenern arbeiten, für den Interpreter
werden oft Visitors eingesetzt.</p>
<p>Die einfachste Form von Interpretern sind die &quot;syntaxgesteuerten Interpreter&quot;. Durch
den Einsatz von attributierten Grammatiken und eingebetteten Aktionen kann in einfachen
Fällen der Programmcode bereits beim Parsen interpretiert werden, d.h. nach dem Parsen
steht das Ergebnis fest.</p>
<p>Normalerweise traversiert man in Interpretern aber den AST, etwa mit dem Listener-
oder Visitor-Pattern. Die in dieser Sitzung gezeigten einfachen Beispiele der
syntaxgesteuerten Interpreter werden erweitert auf die jeweilige Traversierung mit
dem Listener- bzw. Visitor-Pattern. Für nicht so einfache Fälle braucht man aber
zusätzlich noch Speicherstrukturen, die wir in
<a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/lecture/06-interpretation/astdriven-part1.md" rel="external" target="_blank">AST-basierte Interpreter: Basics</a>
und
<a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/lecture/06-interpretation/astdriven-part2.md" rel="external" target="_blank">AST-basierte Interpreter: Funktionen und Klassen</a>
betrachten.</p>
  </div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-podcast"></i> Videos (YouTube)
  </div>
  <div class="box-content">
<ul> <li><a href='https://youtu.be/s5wvvoYsxe4' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Syntaxgesteuerte Interpreter</a></li></ul>
  </div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)
  </div>
  <div class="box-content">
<ul> <li><a href='https://www.hsbi.de/medienportal/m/0e4ffb9743823767da26cf83c54fa2c87293bb9974ccb5b62e9111cccf01954b96fd29a449fc96097f0b8c549d93c720aed4c3fe079795dbe6246081b7c20a8f' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Syntaxgesteuerte Interpreter</a></li></ul>
  </div>
</div>




    
    
    
    






    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    <div class="box notices cstyle tip">
  <div class="box-label">
    <i class="fas fa-lightbulb"></i> Lernziele
  </div>
  <div class="box-content">
<ul> <li>(K3) Attribute und eingebettete Aktionen in Bison und ANTLR</li> <li>(K3) Traversierung von Parse-Trees und Implementierung von Aktionen mit Hilfe des Listener-Patterns</li> <li>(K3) Traversierung von Parse-Trees und Implementierung von Aktionen mit Hilfe des Visitor-Patterns</li></ul>
  </div>
</div>




    <h2 id="überblick-interpreter">Überblick Interpreter</h2>
<p><a href="#R-image-d4cd51285bb1beeb7d63e36de58fbcf1" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/06-interpretation/syntaxdriven/interpreter.png?width=60%25&height=auto" style=" height: auto; width: 60%;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d4cd51285bb1beeb7d63e36de58fbcf1"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/06-interpretation/syntaxdriven/interpreter.png?width=60%25&height=auto"></a></p>
<p>Beim Interpreter durchläuft der Sourcecode nur das Frontend, also die Analyse.
Es wird kein Code erzeugt, stattdessen führt der Interpreter die Anweisungen
im AST bzw. IC aus. Dazu muss der Interpreter mit den Eingabedaten beschickt
werden.</p>
<p>Es gibt verschiedene Varianten, beispielsweise:</p>
<ul>
<li>
<p>Syntaxgesteuerte Interpreter</p>
<ul>
<li>Einfachste Variante, wird direkt im Parser mit abgearbeitet</li>
<li>Keine Symboltabellen, d.h. auch keine Typprüfung oder Vorwärtsdeklarationen o.ä.
(d.h. erlaubt nur vergleichsweise einfache Sprachen)</li>
<li>Beispiel: siehe nächste Folie</li>
</ul>
</li>
<li>
<p>AST-basierte Interpreter</p>
<ul>
<li>Nutzt den AST und Symboltabellen</li>
<li>Beispiel: siehe weiter unten</li>
</ul>
</li>
<li>
<p>Stack-basierte Interpreter</p>
<ul>
<li>Simuliert eine <em>Stack Machine</em>, d.h. hält alle (temporären) Werte auf einem Stack</li>
<li>Arbeitet typischerweise auf bereits stark vereinfachtem Zwischencode (IR),
etwa Bytecode</li>
</ul>
</li>
<li>
<p>Register-basierte Interpreter</p>
<ul>
<li>Simuliert eine <em>Register Machine</em>, d.h. hält alle (temporären) Werte in virtuellen
Prozessor-Registern</li>
<li>Arbeitet typischerweise auf bereits stark vereinfachtem Zwischencode (IR),
etwa Bytecode</li>
</ul>
</li>
</ul>
<p>Weiterhin kann man Interpreter danach unterscheiden, ob sie interaktiv sind oder nicht.
Python kann beispielsweise direkt komplette Dateien verarbeiten oder interaktiv Eingaben
abarbeiten. Letztlich kommen dabei aber die oben dargestellten Varianten zum Einsatz.</p>
<h2 id="syntaxgesteuerte-interpreter-attributierte-grammatiken">Syntaxgesteuerte Interpreter: Attributierte Grammatiken</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>s     : expr                    {System.err.println($expr.v);} ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>expr <span style="color:#66d9ef">returns</span> [int v]
</span></span><span style="display:flex;"><span>      : e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;*&#39;</span> e2<span style="color:#f92672">=</span>expr     {$v = $e1.v * $e2.v;}
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;+&#39;</span> e2<span style="color:#f92672">=</span>expr     {$v = $e1.v + $e2.v;}
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#66d9ef">DIGIT</span>                   {$v = $DIGIT.int;}
</span></span><span style="display:flex;"><span>      ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>DIGIT : [0-9] ;</span></span></code></pre></div>
<p>Die einfachste Form des Interpreters wird direkt beim Parsen ausgeführt und kommt ohne AST aus.
Der Nachteil ist, dass der AST dabei nicht vorverarbeitet werden kann, insbesondere entfallen
semantische Prüfungen weitgehend.</p>
<p>Über <code>returns [int v]</code> fügt man der Regel <code>expr</code> ein Attribut <code>v</code> (Integer) hinzu, welches
man im jeweiligen Kontext abfragen bzw. setzen kann (agiert als Rückgabewert der generierten
Methode). Auf diesen Wert kann in den Aktionen mit <code>$v</code> zugegriffen werden.</p>
<p>Da in den Alternativen der Regel <code>expr</code> jeweils zwei &quot;Aufrufe&quot; dieser Regel auftauchen, muss
man per &quot;<code>e1=expr</code>&quot; bzw. &quot;<code>e2=expr</code>&quot; eindeutige Namen für die &quot;Aufrufe&quot; vergeben, hier <code>e1</code>
und <code>e2</code>.</p>
<h2 id="eingebettete-aktionen-in-antlr-i">Eingebettete Aktionen in ANTLR I</h2>
<p>Erinnerung: ANTLR generiert einen LL-Parser, d.h. es wird zu jeder Regel eine entsprechende
Methode generiert.</p>
<p>Analog zum Rückgabewert der Regel (Methode) <code>expr()</code> kann auf die Eigenschaften der Token und
Sub-Regeln zugegriffen werden: <code>$name.eigenschaft</code>. Dabei gibt es bei Token Eigenschaften wie
<code>text</code> (gematchter Text bei Token), <code>type</code> (Typ eines Tokens), <code>int</code> (Integerwert eines Tokens,
entspricht <code>Integer.valueOf($Token.text)</code>). Parser-Regeln haben u.a. ein <code>text</code>-Attribut und
ein spezielles Kontext-Objekt (<code>ctx</code>).</p>
<p>Die allgemeine Form lautet:</p>
<pre><code>rulename[args] returns [retvals] locals [localvars] : ... ;
</code></pre>
<p>Dabei werden die in &quot;<code>[...]</code>&quot; genannten Parameter mit Komma getrennt (Achtung: Abhängig von
Zielsprache!).</p>
<p>Beispiel:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>add[int x] <span style="color:#66d9ef">returns</span> [int r] : <span style="color:#e6db74">&#39;+=&#39;</span> <span style="color:#66d9ef">INT</span> {$r = $x + $INT.int;} ;</span></span></code></pre></div>
<h2 id="eingebettete-aktionen-in-antlr-ii">Eingebettete Aktionen in ANTLR II</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>@members {
</span></span><span style="display:flex;"><span>    int count = 0;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>expr <span style="color:#66d9ef">returns</span> [int v]
</span></span><span style="display:flex;"><span>      @after {System.out.println(count);}
</span></span><span style="display:flex;"><span>      : e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;*&#39;</span> e2<span style="color:#f92672">=</span>expr     {$v = $e1.v * $e2.v; count++;}
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;+&#39;</span> e2<span style="color:#f92672">=</span>expr     {$v = $e1.v + $e2.v; count++;}
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#66d9ef">DIGIT</span>                   {$v = $DIGIT.int;}
</span></span><span style="display:flex;"><span>      ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>DIGIT : [0-9] ;</span></span></code></pre></div>
<p>Mit <code>@members { ... }</code> können im generierten Parser weitere Attribute angelegt
werden, die in den Regeln normal genutzt werden können.</p>
<p>Die mit <code>@after</code> markierte Aktion wird am Ende der Regel <code>list</code> ausgeführt. Analog
existiert <code>@init</code>.</p>
<h2 id="antlr-traversierung-des-ast-und-auslesen-von-kontext-objekten">ANTLR: Traversierung des AST und Auslesen von Kontext-Objekten</h2>
<p>Mit dem obigen Beispiel, welches dem Einsatz einer L-attributierten SDD in ANTLR
entspricht, können einfache Aufgaben bereits beim Parsen erledigt werden.</p>
<p>Für den etwas komplexeren Einsatz von attributierten Grammatiken kann man die von
ANTLR erzeugten Kontext-Objekte für die einzelnen AST-Knoten nutzen und über den
AST mit dem Visitor- oder dem Listener-Pattern iterieren.</p>
<p>Die Techniken sollen im Folgenden kurz vorgestellt werden.</p>
<h3 id="antlr-kontext-objekte-für-parser-regeln">ANTLR: Kontext-Objekte für Parser-Regeln</h3>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>s    : expr         {List&lt;EContext&gt; x = $expr.ctx.e();} ;
</span></span><span style="display:flex;"><span>expr : e <span style="color:#e6db74">&#39;*&#39;</span> e ;</span></span></code></pre></div>
<p><a href="#R-image-de300c54b2138e9d31b8a1093b55554d" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/06-interpretation/syntaxdriven/ParserRuleContext.png?width=auto&height=auto" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-de300c54b2138e9d31b8a1093b55554d"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/06-interpretation/syntaxdriven/ParserRuleContext.png?width=auto&height=auto"></a></p>
<p>Jede Regel liefert ein passend zu dieser Regel generiertes Kontext-Objekt
zurück. Darüber kann man das/die Kontextobjekt(e) der Sub-Regeln abfragen.</p>
<p>Die Regel <code>s()</code> liefert entsprechend ein <code>SContext</code>-Objekt und die Regel
<code>expr()</code> liefert ein <code>ExprContext</code>-Objekt zurück.</p>
<p>In der Aktion fragt man das Kontextobjekt über <code>ctx</code> ab.</p>
<p>Für einfache Regel-Aufrufe liefert die parameterlose Methode nur ein
einziges Kontextobjekt (statt einer Liste) zurück.</p>
<p><strong>Anmerkung</strong>: ANTLR generiert nur dann Felder für die Regel-Elemente im
Kontextobjekt, wenn diese in irgendeiner Form referenziert werden. Dies
kann beispielsweise durch Benennung (Definition eines Labels, siehe nächste
Folie) oder durch Nutzung in einer Aktion (siehe obiges Beispiel) geschehen.</p>
<h3 id="antlr-benannte-regel-elemente-oder-alternativen">ANTLR: Benannte Regel-Elemente oder Alternativen</h3>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stat  : <span style="color:#e6db74">&#39;return&#39;</span> value<span style="color:#f92672">=</span>e <span style="color:#e6db74">&#39;;&#39;</span>    <span style="color:#f92672">#</span> <span style="color:#66d9ef">Return</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;break&#39;</span> <span style="color:#e6db74">&#39;;&#39;</span>             <span style="color:#f92672">#</span> <span style="color:#66d9ef">Break</span>
</span></span><span style="display:flex;"><span>      ;</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StatContext</span> <span style="color:#66d9ef">extends</span> ParserRuleContext { ... }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ReturnContext</span> <span style="color:#66d9ef">extends</span> StatContext {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> EContext value;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> EContext <span style="color:#a6e22e">e</span>() { ... }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BreakContext</span> <span style="color:#66d9ef">extends</span> StatContext { ... }</span></span></code></pre></div>
<p>Mit <code>value=e</code> wird der Aufruf der Regel <code>e</code> mit dem Label <code>value</code> belegt,
d.h. man kann mit <code>$e.text</code> oder <code>$value.text</code> auf das <code>text</code>-Attribut von
<code>e</code> zugreifen. Falls es in einer Produktion mehrere Aufrufe einer anderen
Regel gibt, <strong>muss</strong> man für den Zugriff auf die Attribute eindeutige Label
vergeben.</p>
<p>Analog wird für die beiden Alternativen je ein eigener Kontext erzeugt.</p>
<h3 id="antlr-arbeiten-mit-dem-listener-pattern">ANTLR: Arbeiten mit dem Listener-Pattern</h3>
<p>ANTLR (generiert auf Wunsch) zur Grammatik passende Listener (Interface und
leere Basisimplementierung). Beim Traversieren mit dem Default-<code>ParseTreeWalker</code>
wird der Parse-Tree mit Tiefensuche abgelaufen und jeweils beim Eintritt in
bzw. beim Austritt aus einen/m Knoten der passende Listener mit dem passenden
Kontext-Objekt aufgerufen.</p>
<p>Damit kann man die Grammatik &quot;für sich&quot; halten, d.h. unabhängig von einer
konkreten Zielsprache und die Aktionen über die Listener (oder Visitors, s.u.)
ausführen.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;*&#39;</span> e2<span style="color:#f92672">=</span>expr      <span style="color:#f92672">#</span> <span style="color:#66d9ef">MULT</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;+&#39;</span> e2<span style="color:#f92672">=</span>expr      <span style="color:#f92672">#</span> <span style="color:#66d9ef">ADD</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">DIGIT</span>                    <span style="color:#f92672">#</span> <span style="color:#66d9ef">ZAHL</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div>
<p>ANTLR kann zu dieser Grammatik einen passenden Listener (Interface <code>calcListener</code>)
generieren. Weiterhin generiert ANTLR eine leere Basisimplementierung (Klasse
<code>calcBaseListener</code>):</p>
<p><a href="#R-image-a17d4d5d6dc0f958dd7af17aec238229" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/06-interpretation/syntaxdriven/ParseTreeListener.png?width=auto&height=auto" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a17d4d5d6dc0f958dd7af17aec238229"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/06-interpretation/syntaxdriven/ParseTreeListener.png?width=auto&height=auto"></a></p>
<p>Von dieser Basisklasse leitet man einen eigenen Listener ab und implementiert
die Methoden, die man benötigt.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyListener</span> <span style="color:#66d9ef">extends</span> calcBaseListener {
</span></span><span style="display:flex;"><span>    Stack<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> stack <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exitMULT</span>(calcParser.<span style="color:#a6e22e">MULTContext</span> ctx) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> stack.<span style="color:#a6e22e">pop</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> stack.<span style="color:#a6e22e">pop</span>();
</span></span><span style="display:flex;"><span>        stack.<span style="color:#a6e22e">push</span>(left <span style="color:#f92672">*</span> right);   <span style="color:#75715e">// {$v = $e1.v * $e2.v;}</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exitADD</span>(calcParser.<span style="color:#a6e22e">ADDContext</span> ctx) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> stack.<span style="color:#a6e22e">pop</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> stack.<span style="color:#a6e22e">pop</span>();
</span></span><span style="display:flex;"><span>        stack.<span style="color:#a6e22e">push</span>(left <span style="color:#f92672">+</span> right);   <span style="color:#75715e">// {$v = $e1.v + $e2.v;}</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exitZAHL</span>(calcParser.<span style="color:#a6e22e">ZAHLContext</span> ctx) {
</span></span><span style="display:flex;"><span>        stack.<span style="color:#a6e22e">push</span>(Integer.<span style="color:#a6e22e">valueOf</span>(ctx.<span style="color:#a6e22e">DIGIT</span>().<span style="color:#a6e22e">getText</span>()));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Anschließend baut man das alles in eine Traversierung des Parse-Trees ein:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestMyListener</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyListener</span> <span style="color:#66d9ef">extends</span> calcBaseListener {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> Exception {
</span></span><span style="display:flex;"><span>        calcLexer lexer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> calcLexer(CharStreams.<span style="color:#a6e22e">fromStream</span>(System.<span style="color:#a6e22e">in</span>));
</span></span><span style="display:flex;"><span>        CommonTokenStream tokens <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CommonTokenStream(lexer);
</span></span><span style="display:flex;"><span>        calcParser parser <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> calcParser(tokens);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ParseTree tree <span style="color:#f92672">=</span> parser.<span style="color:#a6e22e">s</span>();    <span style="color:#75715e">// Start-Regel</span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(tree.<span style="color:#a6e22e">toStringTree</span>(parser));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ParseTreeWalker walker <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ParseTreeWalker();
</span></span><span style="display:flex;"><span>        MyListener eval <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyListener();
</span></span><span style="display:flex;"><span>        walker.<span style="color:#a6e22e">walk</span>(eval, tree);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(eval.<span style="color:#a6e22e">stack</span>.<span style="color:#a6e22e">pop</span>());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/lecture/06-interpretation/src/TestMyListener.java" target="_blank"><span class="title">Beispiel: TestMyListener.java und calc.g4</span></a></span></div>
<h3 id="antlr-arbeiten-mit-dem-visitor-pattern">ANTLR: Arbeiten mit dem Visitor-Pattern</h3>
<p>ANTLR (generiert ebenfalls auf Wunsch) zur Grammatik passende Visitoren
(Interface und leere Basisimplementierung). Hier muss man allerdings selbst
für eine geeignete Traversierung des Parse-Trees sorgen. Dafür hat man mehr
Freiheiten im Vergleich zum Listener-Pattern, insbesondere im Hinblick auf
Rückgabewerte.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;*&#39;</span> e2<span style="color:#f92672">=</span>expr      <span style="color:#f92672">#</span> <span style="color:#66d9ef">MULT</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;+&#39;</span> e2<span style="color:#f92672">=</span>expr      <span style="color:#f92672">#</span> <span style="color:#66d9ef">ADD</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">DIGIT</span>                    <span style="color:#f92672">#</span> <span style="color:#66d9ef">ZAHL</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div>
<p>ANTLR kann zu dieser Grammatik einen passenden Visitor (Interface <code>calcVisitor&lt;T&gt;</code>)
generieren. Weiterhin generiert ANTLR eine leere Basisimplementierung (Klasse
<code>calcBaseVisitor&lt;T&gt;</code>):</p>
<p><a href="#R-image-83bc2160a5d72f23770783a8c5fb22ac" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/06-interpretation/syntaxdriven/ParseTreeVisitor.png?width=auto&height=auto" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-83bc2160a5d72f23770783a8c5fb22ac"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/06-interpretation/syntaxdriven/ParseTreeVisitor.png?width=auto&height=auto"></a></p>
<p>Von dieser Basisklasse leitet man einen eigenen Visitor ab und überschreibt
die Methoden, die man benötigt. Wichtig ist, dass man selbst für das &quot;Besuchen&quot;
der Kindknoten sorgen muss (rekursiver Aufruf der geerbten Methode <code>visit()</code>).</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyVisitor</span> <span style="color:#66d9ef">extends</span> calcBaseVisitor<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Integer <span style="color:#a6e22e">visitMULT</span>(calcParser.<span style="color:#a6e22e">MULTContext</span> ctx) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> visit(ctx.<span style="color:#a6e22e">e1</span>) <span style="color:#f92672">*</span> visit(ctx.<span style="color:#a6e22e">e2</span>);   <span style="color:#75715e">// {$v = $e1.v * $e2.v;}</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Integer <span style="color:#a6e22e">visitADD</span>(calcParser.<span style="color:#a6e22e">ADDContext</span> ctx) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> visit(ctx.<span style="color:#a6e22e">e1</span>) <span style="color:#f92672">+</span> visit(ctx.<span style="color:#a6e22e">e2</span>);   <span style="color:#75715e">// {$v = $e1.v + $e2.v;}</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Integer <span style="color:#a6e22e">visitZAHL</span>(calcParser.<span style="color:#a6e22e">ZAHLContext</span> ctx) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Integer.<span style="color:#a6e22e">valueOf</span>(ctx.<span style="color:#a6e22e">DIGIT</span>().<span style="color:#a6e22e">getText</span>());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Anschließend baut man das alles in eine manuelle Traversierung des Parse-Trees ein:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestMyVisitor</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyVisitor</span> <span style="color:#66d9ef">extends</span> calcBaseVisitor<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> Exception {
</span></span><span style="display:flex;"><span>        calcLexer lexer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> calcLexer(CharStreams.<span style="color:#a6e22e">fromStream</span>(System.<span style="color:#a6e22e">in</span>));
</span></span><span style="display:flex;"><span>        CommonTokenStream tokens <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CommonTokenStream(lexer);
</span></span><span style="display:flex;"><span>        calcParser parser <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> calcParser(tokens);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ParseTree tree <span style="color:#f92672">=</span> parser.<span style="color:#a6e22e">s</span>();    <span style="color:#75715e">// Start-Regel</span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(tree.<span style="color:#a6e22e">toStringTree</span>(parser));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        MyVisitor eval <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyVisitor();
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(eval.<span style="color:#a6e22e">visit</span>(tree));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<div style="text-align: right;"><span class="btn cstyle interactive default"><a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/lecture/06-interpretation/src/TestMyVisitor.java" target="_blank"><span class="title">Beispiel: TestMyVisitor.java und calc.g4</span></a></span></div>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>
<p>Interpreter simulieren die Programmausführung</p>
</li>
<li>
<p>Syntaxgesteuerter Interpreter (attributierte Grammatiken)</p>
</li>
<li>
<p>Beispiel ANTLR: Eingebettete Aktionen, Kontextobjekte, Visitors/Listeners (AST-Traversierung)</p>
</li>
</ul>


    



    



    




    




    
    
        
        

        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-book-reader"></i> Quellen
  </div>
  <div class="box-content">
<ul> <li id='id_Nystrom2021'>[Nystrom2021] <a href='https://github.com/munificent/craftinginterpreters' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>Crafting Interpreters</strong></a><br>Nystrom, R., Genever Benning, 2021. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-0-9905829-3-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-0-9905829-3-9</a>.<br><em>Kapitel: A Tree-Walk Interpreter</em></li> <li id='id_Parr2010'>[Parr2010] <a href='https://learning.oreilly.com/library/view/language-implementation-patterns/9781680500097/' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>Language Implementation Patterns</strong></a><br>Parr, T., Pragmatic Bookshelf, 2010. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5645-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5645-6</a>.<br><em>Kapitel 8 und 9</em></li> <li id='id_Parr2014'>[Parr2014] <a href='https://learning.oreilly.com/library/view/the-definitive-antlr/9781941222621/' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>The Definitive ANTLR 4 Reference</strong></a><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.<br><em>Kapitel 6.4 und 8.4</em></li></ul>
  </div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin-left: 4rem; margin-right: 4rem; margin-top: 6rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>AST-basierte Interpreter: Basics</h1>



    



    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-graduation-cap"></i> TL;DR
  </div>
  <div class="box-content">
<p>Ein AST-basierter Interpreter besteht oft aus einem &quot;Visitor-Dispatcher&quot;: Man traversiert
mit einer <code>eval()</code>-Funktion den AST und ruft je nach Knotentyp die passende Funktion auf.
Dabei werden bei Ausdrücken (<em>Expressions</em>) Werte berechnet und zurückgegeben, d.h. hier
hat man einen Rückgabewert und ein entsprechendes <code>return</code> im <code>switch</code>/<code>case</code>, während man
bei Anweisungen (<em>Statements</em>) keinen Rückgabewert hat.</p>
<p>Der Wert von Literalen ergibt sich direkt durch die Übersetzung des jeweiligen Werts in den
passenden Typ der Implementierungssprache. Bei einfachen Ausdrücken kann man auf das in
<a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/lecture/06-interpretation/syntaxdriven.md" rel="external" target="_blank">Syntaxgesteuerte Interpreter</a>
demonstrierte Vorgehen zurückgreifen: Man interpretiert zunächst die Teilausdrücke durch den
Aufruf von <code>eval()</code> für die jeweiligen AST-Kindknoten und berechnet daraus das gewünschte
Ergebnis.</p>
<p>Für Blöcke und Variablen muss man analog zum Aufbau von Symboltabellen wieder Scopes
berücksichtigen, d.h. man benötigt Strukturen ähnlich zu den Symboltabellen (hier &quot;Umgebung&quot;
(<em>Environment</em>) genannt). Es gibt eine globale Umgebung, und mit dem Betreten eines neuen
Blocks wird eine neue Umgebung aufgemacht, deren Eltern-Umgebung die bisherige Umgebung ist.</p>
<p>Zu jedem Namen kann man in einer Umgebung einen Wert definieren bzw. abrufen. Dabei muss man
je nach Semantik der zu interpretierenden Sprache unterscheiden zwischen der &quot;Definition&quot; und
der &quot;Zuweisung&quot; einer Variablen: Die Definition erfolgt i.d.R. in der aktuellen Umgebung, bei
der Zuweisung sucht man ausgehend von der aktuellen Umgebung bis hoch zur globalen Umgebung
nach dem ersten Vorkommen der Variablen und setzt den Wert in der gefundenen Umgebung. Bei
Sprachen, die Variablen beim ersten Zugriff definieren, muss man dieses Verhalten entsprechend
anpassen.</p>
  </div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-podcast"></i> Videos (YouTube)
  </div>
  <div class="box-content">
<ul> <li><a href='https://youtu.be/lupQ0f3Tp7A' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL AST-basierte Interpreter (Basics)</a></li></ul>
  </div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)
  </div>
  <div class="box-content">
<ul> <li><a href='https://www.hsbi.de/medienportal/m/18b6c77bbd5ecc90730df421e3ed175ae4670f56dd8b1a7bdd517066a2b1e7669e074c8f473e88f7f6073f2bd25092ceca16eee95953412a7f9fa5597a7acd9a' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL AST-basierte Interpreter (Basics)</a></li></ul>
  </div>
</div>




    
    
    
    






    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    <div class="box notices cstyle tip">
  <div class="box-label">
    <i class="fas fa-lightbulb"></i> Lernziele
  </div>
  <div class="box-content">
<ul> <li>(K3) Traversierung von Parse-Trees und Implementierung von Aktionen mit Hilfe des Visitor-Patterns</li> <li>(K3) Interpreter müssen Namen und Werte speichern: Environment-Strukturen analog zu den Symboltabellen</li> <li>(K3) Code-Ausführung im Interpreter durch eine Read-Eval-Schleife: Implementierung mit einem Visitor</li></ul>
  </div>
</div>




    <h2 id="aufgaben-im-interpreter">Aufgaben im Interpreter</h2>
<p>Im Allgemeinen reichen einfache syntaxgesteuerte Interpreter nicht aus. Normalerweise simuliert
ein Interpreter die Ausführung eines Programms durch den Computer. D.h. der Interpreter muss
über die entsprechenden Eigenschaften verfügen: Prozessor, Code-Speicher, Datenspeicher, Stack ...</p>
<div class='columns'>
<div class='column'>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">int</span> x) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> y<span style="color:#f92672">+</span>x;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#a6e22e">f</span>(x);</span></span></code></pre></div>
</div>
<div class='column'>
<ul>
<li>
<p>Aufbauen des AST ... =&gt; Lexer+Parser</p>
</li>
<li>
<p>Auflösen von Symbolen/Namen ... =&gt; Symboltabellen, Resolving</p>
</li>
<li>
<p>Type-Checking und -Inference ... =&gt; Semantische Analyse (auf Symboltabellen)</p>
</li>
<li>
<p>Speichern von Daten: Name+Wert vs. Adresse+Wert (Erinnerung: Data-Segment und Stack im virtuellen Speicher)</p>
</li>
<li>
<p>Ausführen von Anweisungen Text-Segment im virtuellen Speicher; hier über den AST</p>
</li>
<li>
<p>Aufruf von Funktionen und Methoden Kontextwechsel nötig: Was ist von wo aus sichtbar?</p>
</li>
</ul>
</div>
</div>
<h2 id="ast-basierte-interpreter-visitor-dispatcher">AST-basierte Interpreter: Visitor-Dispatcher</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">eval</span>(self, AST t):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>   t<span style="color:#f92672">.</span>type <span style="color:#f92672">==</span> Parser<span style="color:#f92672">.</span>BLOCK  : block(t)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> t<span style="color:#f92672">.</span>type <span style="color:#f92672">==</span> Parser<span style="color:#f92672">.</span>ASSIGN : assign(t)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> t<span style="color:#f92672">.</span>type <span style="color:#f92672">==</span> Parser<span style="color:#f92672">.</span>RETURN : ret(t)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> t<span style="color:#f92672">.</span>type <span style="color:#f92672">==</span> Parser<span style="color:#f92672">.</span>IF     : ifstat(t)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> t<span style="color:#f92672">.</span>type <span style="color:#f92672">==</span> Parser<span style="color:#f92672">.</span>CALL   : <span style="color:#66d9ef">return</span> call(t)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> t<span style="color:#f92672">.</span>type <span style="color:#f92672">==</span> Parser<span style="color:#f92672">.</span>ADD    : <span style="color:#66d9ef">return</span> add(t)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> t<span style="color:#f92672">.</span>type <span style="color:#f92672">==</span> Parser<span style="color:#f92672">.</span>MUL    : <span style="color:#66d9ef">return</span> mul(t)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> t<span style="color:#f92672">.</span>type <span style="color:#f92672">==</span> Parser<span style="color:#f92672">.</span>INT    : <span style="color:#66d9ef">return</span> Integer<span style="color:#f92672">.</span>parseInt(t<span style="color:#f92672">.</span>getText())
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> t<span style="color:#f92672">.</span>type <span style="color:#f92672">==</span> Parser<span style="color:#f92672">.</span>ID     : <span style="color:#66d9ef">return</span> load(t)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> : <span style="color:#f92672">...</span>  <span style="color:#75715e"># catch unhandled node types</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>;</span></span></code></pre></div>
<p>Nach dem Aufbau des AST durch Scanner und Parser und der semantischen Analyse
anhand der Symboltabellen müssen die Ausdrücke (<em>expressions</em>) und Anweisungen
(<em>statements</em>) durch den Interpreter ausgewertet werden. Eine Möglichkeit dazu
ist das Traversieren des AST mit dem Visitor-Pattern. Basierend auf dem Typ
des aktuell betrachteten AST-Knotens wird entschieden, wie damit umgegangen
werden soll. Dies erinnert an den Aufbau der Symboltabellen ...</p>
<p>Die <code>eval()</code>-Methode bildet das Kernstück des (AST-traversierenden) Interpreters.
Hier wird passend zum aktuellen AST-Knoten die passende Methode des Interpreters
aufgerufen.</p>
<p><strong>Hinweis</strong>: Im obigen Beispiel wird nicht zwischen der Auswertung von
Ausdrücken und Anweisungen unterschieden, es wird die selbe Methode <code>eval()</code>
genutzt. Allerdings liefern Ausdrücke einen Wert zurück (erkennbar am <code>return</code>
im jeweiligen <code>switch/case</code>-Zweig), während Anweisungen keinen Wert liefern.</p>
<p>In den folgenden Beispielen wird davon ausgegangen, dass ein komplettes
Programm eingelesen, geparst, vorverarbeitet und dann interpretiert wird.</p>
<p>Für einen interaktiven Interpreter würde man in einer Schleife die Eingaben
lesen, parsen und vorverarbeiten und dann interpretieren. Dabei würde jeweils
der AST und die Symboltabelle <em>ergänzt</em>, damit die neuen Eingaben auf frühere
verarbeitete Eingaben zurückgreifen können. Durch die Form der Schleife
&quot;Einlesen -- Verarbeiten -- Auswerten&quot; hat sich auch der Name &quot;<em>Read-Eval-Loop</em>&quot;
bzw. &quot;<em>Read-Eval-Print-Loop</em>&quot; (<strong>REPL</strong>) eingebürgert.</p>
<h2 id="auswertung-von-literalen-und-ausdrücken">Auswertung von Literalen und Ausdrücken</h2>
<ul>
<li>
<p>Typen mappen: Zielsprache =&gt; Implementierungssprache</p>
<p>Die in der Zielsprache verwendeten (primitiven) Typen müssen
auf passende Typen der Sprache, in der der Interpreter selbst
implementiert ist, abgebildet werden.</p>
<p>Beispielsweise könnte man den Typ <code>nil</code> der Zielsprache auf den
Typ <code>null</code> des in Java implementierten Interpreters abbilden, oder
den Typ <code>number</code> der Zielsprache auf den Typ <code>Double</code> in Java
mappen.</p>
</li>
<li>
<p>Literale auswerten:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>INT: [0-9]<span style="color:#f92672">+</span> ;</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">elif</span> t<span style="color:#f92672">.</span>type <span style="color:#f92672">==</span> Parser<span style="color:#f92672">.</span>INT : <span style="color:#66d9ef">return</span> Integer<span style="color:#f92672">.</span>parseInt(t<span style="color:#f92672">.</span>getText())</span></span></code></pre></div>
<p>Das ist der einfachste Teil ... Die primitiven Typen der
Zielsprache, für die es meist ein eigenes Token gibt, müssen
als Datentyp der Interpreter-Programmiersprache ausgewertet
werden.</p>
</li>
<li>
<p>Ausdrücke auswerten:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>add: e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#34;+&#34;</span> e2<span style="color:#f92672">=</span>expr ;</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">add</span>(self, AST t):
</span></span><span style="display:flex;"><span>    lhs <span style="color:#f92672">=</span> eval(t<span style="color:#f92672">.</span>e1())
</span></span><span style="display:flex;"><span>    rhs <span style="color:#f92672">=</span> eval(t<span style="color:#f92672">.</span>e2())
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (double)lhs <span style="color:#f92672">+</span> (double)rhs  <span style="color:#75715e"># Semantik!</span></span></span></code></pre></div>
<p>Die meisten möglichen Fehlerzustände sind bereits durch den Parser
und bei der semantischen Analyse abgefangen worden. Falls zur Laufzeit
die Auswertung der beiden Summanden keine Zahl ergibt, würde eine
Java-Exception geworfen, die man an geeigneter Stelle fangen und
behandeln muss. Der Interpreter soll sich ja nicht mit einem Stack-Trace
verabschieden, sondern soll eine Fehlermeldung präsentieren und danach
normal weiter machen ...</p>
</li>
</ul>
<h2 id="kontrollstrukturen">Kontrollstrukturen</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>ifstat: <span style="color:#e6db74">&#39;if&#39;</span> expr <span style="color:#e6db74">&#39;then&#39;</span> s1<span style="color:#f92672">=</span>stat <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;else&#39;</span> s2<span style="color:#f92672">=</span>stat<span style="color:#f92672">)?</span> ;</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ifstat</span>(self, AST t):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> eval(t<span style="color:#f92672">.</span>expr()): eval(t<span style="color:#f92672">.</span>s1())
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> t<span style="color:#f92672">.</span>s2(): eval(t<span style="color:#f92672">.</span>s2())</span></span></code></pre></div>
<p>Analog können die anderen bekannten Kontrollstrukturen umgesetzt werden,
etwa <code>switch/case</code>, <code>while</code> oder <code>for</code>.</p>
<p>Dabei können erste Optimierungen vorgenommen werden: Beispielsweise könnten
<code>for</code>-Schleifen im Interpreter in <code>while</code>-Schleifen transformiert werden,
wodurch im Interpreter nur ein Schleifenkonstrukt implementiert werden
müsste.</p>
<h2 id="zustände-auswerten-von-anweisungen">Zustände: Auswerten von Anweisungen</h2>
<div class='columns'>
<div class='column'>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> y;
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    y <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    { <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> x; }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
</div>
<div class='column'>
<p><a href="#R-image-8ef4600588478e4f252926aadd062897" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/06-interpretation/astdriven-part1/nested_envs.png?width=auto&height=auto" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8ef4600588478e4f252926aadd062897"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/06-interpretation/astdriven-part1/nested_envs.png?width=auto&height=auto"></a></p>
</div>
</div>
<p>Das erinnert nicht nur zufällig an den Aufbau der Symboltabellen :-)</p>
<p>Und so lange es nur um Variablen ginge, könnte man die Symboltabellen für das
Speichern der Werte nutzen. Allerdings müssen wir noch Funktionen und Strukturen
bzw. Klassen realisieren, und spätestens dann kann man die Symboltabelle nicht
mehr zum Speichern von Werten einsetzen. Also lohnt es sich, direkt neue
Strukturen für das Halten von Variablen und Werten aufzubauen.</p>
<h2 id="detail-felder-im-interpreter">Detail: Felder im Interpreter</h2>
<p>Eine mögliche Implementierung für einen Interpreter basierend auf einem
ANTLR-Visitor ist nachfolgend gezeigt.</p>
<p><strong>Hinweis</strong>: Bei der Ableitung des <code>BaseVisitor&lt;T&gt;</code> muss der Typ <code>T</code>
festgelegt werden. Dieser fungiert als Rückgabetyp für die Visitor-Methoden.
Entsprechend können alle Methoden nur einen gemeinsamen (Ober-) Typ zurückliefern,
weshalb man sich an der Stelle oft mit <code>Object</code> behilft und dann manuell
den konkreten Typ abfragen und korrekt casten muss.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Interpreter</span>(BaseVisitor<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span>):
</span></span><span style="display:flex;"><span>    __init__(self, AST t):
</span></span><span style="display:flex;"><span>        BaseVisitor<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;.</span>__init__(self)
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>root <span style="color:#f92672">=</span> t
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>env <span style="color:#f92672">=</span> Environment()</span></span></code></pre></div>
<p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="https://github.com/munificent/craftinginterpreters/blob/master/java/com/craftinginterpreters/lox/Interpreter.java#L21" rel="external" target="_blank">Interpreter.java</a> by <a href="https://github.com/munificent" rel="external" target="_blank">Bob Nystrom</a> on Github.com (<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" rel="external" target="_blank">MIT</a>)</span></p>
<h2 id="ausführen-einer-variablendeklaration">Ausführen einer Variablendeklaration</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>varDecl: <span style="color:#e6db74">&#34;var&#34;</span> <span style="color:#66d9ef">ID</span> <span style="color:#f92672">(</span><span style="color:#e6db74">&#34;=&#34;</span> expr<span style="color:#f92672">)?</span> <span style="color:#e6db74">&#34;;&#34;</span> ;</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">varDecl</span>(self, AST t):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># deklarierte Variable (String)</span>
</span></span><span style="display:flex;"><span>    name <span style="color:#f92672">=</span> t<span style="color:#f92672">.</span>ID()<span style="color:#f92672">.</span>getText()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    value <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>;  <span style="color:#75715e"># TODO: Typ der Variablen beachten (Defaultwert)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> t<span style="color:#f92672">.</span>expr(): value <span style="color:#f92672">=</span> eval(t<span style="color:#f92672">.</span>expr())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>env<span style="color:#f92672">.</span>define(name, value)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span></span></span></code></pre></div>
<p>Wenn wir bei der Traversierung des AST mit <code>eval()</code> bei einer Variablendeklaration
vorbeikommen, also etwa <code>int x;</code> oder <code>int x = wuppie + fluppie;</code>, dann wird im
<strong>aktuellen</strong> Environment der String &quot;x&quot; sowie der Wert (im zweiten Fall) eingetragen.</p>
<h2 id="ausführen-einer-zuweisung">Ausführen einer Zuweisung</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>assign: <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#34;=&#34;</span> expr;</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">assign</span>(self, AST t):
</span></span><span style="display:flex;"><span>    lhs <span style="color:#f92672">=</span> t<span style="color:#f92672">.</span>ID()<span style="color:#f92672">.</span>getText()
</span></span><span style="display:flex;"><span>    value <span style="color:#f92672">=</span> eval(t<span style="color:#f92672">.</span>expr())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>env<span style="color:#f92672">.</span>assign(lhs, value)  <span style="color:#75715e"># Semantik!</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Environment</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">assign</span>(self, String n, Object v):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>values[n]: self<span style="color:#f92672">.</span>values[n] <span style="color:#f92672">=</span> v
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> self<span style="color:#f92672">.</span>enclosing: self<span style="color:#f92672">.</span>enclosing<span style="color:#f92672">.</span>assign(n, v)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>: <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">RuntimeError</span>(n, <span style="color:#e6db74">&#34;undefined variable&#34;</span>)</span></span></code></pre></div>
<p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="https://github.com/munificent/craftinginterpreters/blob/master/java/com/craftinginterpreters/lox/Environment.java#L38" rel="external" target="_blank">Environment.java</a> by <a href="https://github.com/munificent" rel="external" target="_blank">Bob Nystrom</a> on Github.com (<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" rel="external" target="_blank">MIT</a>)</span></p>
<p>Wenn wir bei der Traversierung des AST mit <code>eval()</code> bei einer Zuweisung
vorbeikommen, also etwa <code>x = 7;</code> oder <code>x = wuppie + fluppie;</code>, dann wird
zunächst im aktuellen Environment die rechte Seite der Zuweisung ausgewertet
(Aufruf von <code>eval()</code>). Anschließend wird der Wert für die Variable im
Environment eingetragen: Entweder sie wurde im aktuellen Environment früher
bereits definiert, dann wird der neue Wert hier eingetragen. Ansonsten wird
entlang der Verschachtelungshierarchie gesucht und entsprechend eingetragen.
Falls die Variable nicht gefunden werden kann, wird eine Exception ausgelöst.</p>
<p>An dieser Stelle kann man über die Methode <code>assign</code> in der Klasse <code>Environment</code>
dafür sorgen, dass nur bereits deklarierte Variablen zugewiesen werden dürfen.
Wenn man stattdessen wie etwa in Python das implizite Erzeugen neuer
Variablen erlaubten möchte, würde man statt <code>Environment#assign</code> einfach
<code>Environment#define</code> nutzen ...</p>
<p><em>Anmerkung</em>: Der gezeigte Code funktioniert nur für normale Variablen, nicht
für Zugriffe auf Attribute einer Struct oder Klasse!</p>
<h2 id="blöcke-umgang-mit-verschachtelten-environments">Blöcke: Umgang mit verschachtelten Environments</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>block:  <span style="color:#e6db74">&#39;{&#39;</span> stat<span style="color:#f92672">*</span> <span style="color:#e6db74">&#39;}&#39;</span> ;</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">block</span>(self, AST t):
</span></span><span style="display:flex;"><span>    prev <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>env
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>env <span style="color:#f92672">=</span> Environment(self<span style="color:#f92672">.</span>env)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> t<span style="color:#f92672">.</span>stat(): eval(s)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">finally</span>: self<span style="color:#f92672">.</span>env <span style="color:#f92672">=</span> prev
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>;</span></span></code></pre></div>
<p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="https://github.com/munificent/craftinginterpreters/blob/master/java/com/craftinginterpreters/lox/Interpreter.java#L92" rel="external" target="_blank">Interpreter.java</a> by <a href="https://github.com/munificent" rel="external" target="_blank">Bob Nystrom</a> on Github.com (<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" rel="external" target="_blank">MIT</a>)</span></p>
<p>Beim Interpretieren von Blöcken muss man einfach nur eine weitere
Verschachtelungsebene für die Environments anlegen und darin dann
die Anweisungen eines Blockes auswerten ...</p>
<p><strong>Wichtig</strong>: Egal, was beim Auswerten der Anweisungen in einem Block
passiert: Es muss am Ende die ursprüngliche Umgebung wieder hergestellt
werden (<code>finally</code>-Block).</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>
<p>Interpreter simulieren die Programmausführung</p>
<ul>
<li>Namen und Symbole auflösen</li>
<li>Speicherbereiche simulieren</li>
<li>Code ausführen: Read-Eval-Loop</li>
</ul>
</li>
<li>
<p>Traversierung des AST: <code>eval(AST t)</code> als Visitor-Dispatcher</p>
</li>
<li>
<p>Scopes mit <code>Environment</code> (analog zu Symboltabellen)</p>
</li>
<li>
<p>Interpretation von Blöcken und Variablen (Deklaration, Zuweisung)</p>
</li>
</ul>


    



    



    




    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-book-reader"></i> Quellen
  </div>
  <div class="box-content">
<ul> <li id='id_Grune2012'>[Grune2012] <strong>Modern Compiler Design</strong><br>Grune, D. und van, Reeuwijk, K. und Bal, H. E. und Jacobs, C. J. H. und Langendoen, K., Springer, 2012. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-4614-4698-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-4614-4698-9</a>.<br><em>Kapitel 6</em></li> <li id='id_Mogensen2017'>[Mogensen2017] <strong>Introduction to Compiler Design</strong><br>Mogensen, T., Springer, 2017. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-319-66966-3</a>. DOI <a href='https://doi.org/10.1007/978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-319-66966-3</a>.<br><em>Kapitel 4</em></li> <li id='id_Nystrom2021'>[Nystrom2021] <a href='https://github.com/munificent/craftinginterpreters' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>Crafting Interpreters</strong></a><br>Nystrom, R., Genever Benning, 2021. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-0-9905829-3-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-0-9905829-3-9</a>.<br><em>Kapitel Kapitel: A Tree-Walk Interpreter, insb. 8. Statements and State</em></li></ul>
  </div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin-left: 4rem; margin-right: 4rem; margin-top: 6rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>AST-basierte Interpreter: Funktionen und Klassen</h1>



    



    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-graduation-cap"></i> TL;DR
  </div>
  <div class="box-content">
<p>Üblicherweise können Funktionen auf die Umgebung zurückgreifen, in der die Definition der
Funktion erfolgt ist (<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" rel="external" target="_blank">&quot;<strong>Closure</strong>&quot;</a>).
Deshalb wird beim Interpretieren einer Funktionsdefinition der jeweilige AST-Knoten (mit
dem Block des Funktionskörpers) und die aktuelle Umgebung in einer Struktur zusammengefasst.
Zusätzlich muss in der aktuellen Umgebung der Name der Funktion zusammen mit der eben erzeugten
Struktur (&quot;Funktionsobjekt&quot;) als Wert definiert werden.</p>
<p>Beim Funktionsaufruf löst man den Funktionsnamen in der aktuellen Umgebung auf und erhält
das Funktionsobjekt mit dem AST der Funktion und der Closure. Die Funktionsparameter werden
ebenfalls in der aktuellen Umgebung aufgelöst (Aufruf von <code>eval()</code> für die AST-Kindknoten
des Funktionsaufrufs). Zur Interpretation der Funktion legt man sich eine neue Umgebung an,
deren Eltern-Umgebung die Closure der Funktion ist, definiert die Funktionsparameter (Name
und eben ermittelter Wert) in dieser neuen Umgebung und interpretiert dann den AST-Kindknoten
des Funktionsblocks in dieser neuen Umgebung. Für den Rückgabewert muss man ein wenig tricksen:
Ein Block hat normalerweise keinen Wert. Eine Möglichkeit wäre, bei der Interpretation eines
<code>return</code>-Statements eine Exception mit dem Wert des Ausdruck hinter dem &quot;<code>return</code>&quot; zu werfen
und im <code>eval()</code> des Funktionsblock zu fangen.</p>
<p>Für Klassen kann man analog verfahren. Methoden sind zunächst einfach Funktionen, die in einem
Klassenobjekt gesammelt werden. Das Erzeugen einer Instanz einer Klasse ist die Interpretation
eines &quot;Aufrufs&quot; der Klasse (analog zum Aufruf einer Funktion): Dabei wird ein spezielles
Instanzobjekt erzeugt, welches auf die Klasse verweist und welches die Werte der Attribute hält.
Beim Aufruf von Methoden auf einem Instanzobjekt wird der Name der Funktion über das Klassenobjekt
aufgelöst, eine neue Umgebung erzeugt mit der Closure der Funktion als Eltern-Umgebung und das
Instanzobjekt wird in dieser Umgebung definiert als &quot;<code>this</code>&quot; oder &quot;<code>self</code>&quot;. Anschließend wird
ein neues Funktionsobjekt mit der eben erzeugten Umgebung und dem Funktions-AST erzeugt und
zurückgeliefert. Dieses neue Funktionsobjekt wird dann wie eine normale Funktion aufgerufen
(interpretiert, s.o.). Der Zugriff in der Methode auf die Attribute der Klasse erfolgt dann
über <code>this</code> bzw. <code>self</code>, welche in der Closure der Funktion nun definiert sind und auf das
Instanzobjekt mit den Attributen verweisen.</p>
  </div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-podcast"></i> Videos (YouTube)
  </div>
  <div class="box-content">
<ul> <li><a href='https://youtu.be/LTqk7ifB-V0' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL AST-basierte Interpreter (Funktionen, Klassen)</a></li></ul>
  </div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)
  </div>
  <div class="box-content">
<ul> <li><a href='https://www.hsbi.de/medienportal/m/725097f1ce3ef3f10dd1d31674e1b18e89e8b58af259705080b78ccba9dd319d7be76884549c9c59e02fde9e1a2a91ae5aa3a6d44a8e200a2323e08e217faa14' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL AST-basierte Interpreter (Funktionen, Klassen)</a></li></ul>
  </div>
</div>




    
    
    
    






    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    <div class="box notices cstyle tip">
  <div class="box-label">
    <i class="fas fa-lightbulb"></i> Lernziele
  </div>
  <div class="box-content">
<ul> <li>(K3) Traversierung von Parse-Trees und Implementierung von Aktionen mit Hilfe des Visitor-Patterns</li> <li>(K3) Interpreter müssen Namen und Werte speichern: Environment-Strukturen analog zu den Symboltabellen</li> <li>(K3) Code-Ausführung im Interpreter durch eine Read-Eval-Schleife: Implementierung mit einem Visitor</li></ul>
  </div>
</div>




    <h2 id="funktionen">Funktionen</h2>
<div class='columns'>
<div class='column'>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">foo</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b, <span style="color:#66d9ef">int</span> c) {
</span></span><span style="display:flex;"><span>    print a <span style="color:#f92672">+</span> b <span style="color:#f92672">+</span> c;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>foo(1, 2, 3);</span></span></code></pre></div>
</div>
<div class='column'>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">makeCounter</span>():
</span></span><span style="display:flex;"><span>    var i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">count</span>():
</span></span><span style="display:flex;"><span>        i <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        print i
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> count;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>counter <span style="color:#f92672">=</span> makeCounter()
</span></span><span style="display:flex;"><span>counter()   <span style="color:#75715e"># &#34;1&#34;</span>
</span></span><span style="display:flex;"><span>counter()   <span style="color:#75715e"># &#34;2&#34;</span></span></span></code></pre></div>
</div>
</div>
<p>Die Funktionsdeklaration muss im aktuellen Kontext abgelegt werden,
dazu wird der AST-Teilbaum der Deklaration benötigt.</p>
<p>Beim Aufruf muss man das Funktionssymbol im aktuellen Kontext
suchen, die Argumente auswerten, einen neuen lokalen Kontext
anlegen und darin die Parameter definieren (mit den eben ausgewerteten
Werten) und anschließend den AST-Teilbaum des Funktionskörpers im
Interpreter mit <code>eval()</code> auswerten ...</p>
<h2 id="ausführen-einer-funktionsdeklaration">Ausführen einer Funktionsdeklaration</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>funcDecl : type <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;(&#39;</span> params<span style="color:#f92672">?</span> <span style="color:#e6db74">&#39;)&#39;</span> block ;
</span></span><span style="display:flex;"><span>funcCall : <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;(&#39;</span> exprList<span style="color:#f92672">?</span> <span style="color:#e6db74">&#39;)&#39;</span> ;</span></span></code></pre></div>
<div class='columns'>
<div class='column'>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">funcDecl</span>(self, AST t):
</span></span><span style="display:flex;"><span>    fn <span style="color:#f92672">=</span> Fun(t, self<span style="color:#f92672">.</span>env)
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>env<span style="color:#f92672">.</span>define(t<span style="color:#f92672">.</span>ID()<span style="color:#f92672">.</span>getText(), fn)</span></span></code></pre></div>
</div>
<div class='column'>
<p><a href="#R-image-314a10ace5cd56c1693d2337eb884e71" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/06-interpretation/astdriven-part2/fun.png?width=auto&height=auto" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-314a10ace5cd56c1693d2337eb884e71"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/06-interpretation/astdriven-part2/fun.png?width=auto&height=auto"></a></p>
</div>
</div>
<p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="https://github.com/munificent/craftinginterpreters/blob/master/java/com/craftinginterpreters/lox/LoxFunction.java#L6" rel="external" target="_blank">LoxFunction.java</a> by <a href="https://github.com/munificent" rel="external" target="_blank">Bob Nystrom</a> on Github.com (<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" rel="external" target="_blank">MIT</a>)</span></p>
<p>Man definiert im aktuellen Environment den Funktionsnamen und hält dazu
den aktuellen Kontext (aktuelles Environment) sowie den AST-Knoten mit
der eigentlichen Funktionsdefinition fest.</p>
<p>Für <em>Closures</em> ist der aktuelle Kontext wichtig, sobald man die
Funktion ausführen muss. In <a href="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/06-interpretation/astdriven-part2.html#id_Parr2010">[Parr2010, S.236]</a> wird beispielsweise
einfach nur ein neuer Memory-Space (entspricht ungefähr hier einem
neuen lokalen Environment) angelegt, in dem die im Funktionskörper
definierten Symbole angelegt werden. Die Suche nach Symbolen erfolgt
dort nur im Memory-Space (Environment) der Funktion bzw. im globalen
Scope (Environment).</p>
<h2 id="ausführen-eines-funktionsaufrufs">Ausführen eines Funktionsaufrufs</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>funcDecl : type <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;(&#39;</span> params<span style="color:#f92672">?</span> <span style="color:#e6db74">&#39;)&#39;</span> block ;
</span></span><span style="display:flex;"><span>funcCall : <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;(&#39;</span> exprList<span style="color:#f92672">?</span> <span style="color:#e6db74">&#39;)&#39;</span> ;</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">funcCall</span>(self, AST t):
</span></span><span style="display:flex;"><span>    fn <span style="color:#f92672">=</span> (Fun)eval(t<span style="color:#f92672">.</span>ID())
</span></span><span style="display:flex;"><span>    args <span style="color:#f92672">=</span> [eval(a)  <span style="color:#66d9ef">for</span> a <span style="color:#f92672">in</span> t<span style="color:#f92672">.</span>exprList()]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    prev <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>env;  self<span style="color:#f92672">.</span>env <span style="color:#f92672">=</span> Environment(fn<span style="color:#f92672">.</span>closure)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(args<span style="color:#f92672">.</span>size()):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>env<span style="color:#f92672">.</span>define(fn<span style="color:#f92672">.</span>decl<span style="color:#f92672">.</span>params()[i]<span style="color:#f92672">.</span>getText(), args[i])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    eval(fn<span style="color:#f92672">.</span>decl<span style="color:#f92672">.</span>block())
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>env <span style="color:#f92672">=</span> prev</span></span></code></pre></div>
<p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="https://github.com/munificent/craftinginterpreters/blob/master/java/com/craftinginterpreters/lox/LoxFunction.java#L57" rel="external" target="_blank">LoxFunction.java</a> by <a href="https://github.com/munificent" rel="external" target="_blank">Bob Nystrom</a> on Github.com (<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" rel="external" target="_blank">MIT</a>)</span></p>
<p>Zunächst wird die <code>ID</code> im aktuellen Kontext ausgewertet. In der obigen Grammatik
ist dies tatsächlich nur ein Funktionsname, aber man könnte über diesen Mechanismus
auch Ausdrücke erlauben und damit Funktionspointer bzw. Funktionsreferenzen
realisieren ... Im Ergebnis hat man das Funktionsobjekt mit dem zugehörigen AST-Knoten
und dem Kontext zur Deklarationszeit.</p>
<p>Die Argumente der Funktion werden nacheinander ebenfalls im aktuellen Kontext
ausgewertet.</p>
<p>Um den Funktionsblock auszuwerten, legt man einen neuen temporären Kontext über
dem Closure-Kontext der Funktion an und definiert darin die Parameter der Funktion
samt den aktuellen Werten. Dann lässt man den Interpreter über den Visitor-Dispatch
den Funktionskörper evaluieren und schaltet wieder auf den Kontext vor der
Funktionsauswertung zurück.</p>
<h2 id="funktionsaufruf-rückgabewerte">Funktionsaufruf: Rückgabewerte</h2>
<div class='columns'>
<div class='column'>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">funcCall</span>(self, AST t):
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    eval(fn<span style="color:#f92672">.</span>decl<span style="color:#f92672">.</span>block())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>  <span style="color:#75715e"># (Wirkung)</span></span></span></code></pre></div>
</div>
<div class='column'>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ReturnEx</span>(RuntimeException):
</span></span><span style="display:flex;"><span>    __init__(self, v): self<span style="color:#f92672">.</span>value <span style="color:#f92672">=</span> v
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">return</span>(self, AST t):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">raise</span> ReturnEx(eval(t<span style="color:#f92672">.</span>expr()))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">funcCall</span>(self, AST t):
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    erg <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>: eval(fn<span style="color:#f92672">.</span>decl<span style="color:#f92672">.</span>block())
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">except</span> ReturnEx <span style="color:#66d9ef">as</span> r: erg <span style="color:#f92672">=</span> r<span style="color:#f92672">.</span>value
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> erg;</span></span></code></pre></div>
</div>
</div>
<p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="https://github.com/munificent/craftinginterpreters/blob/master/java/com/craftinginterpreters/lox/Return.java#L4" rel="external" target="_blank">Return.java</a> und <a href="https://github.com/munificent/craftinginterpreters/blob/master/java/com/craftinginterpreters/lox/LoxFunction.java#L74" rel="external" target="_blank">LoxFunction.java</a> by <a href="https://github.com/munificent" rel="external" target="_blank">Bob Nystrom</a> on Github.com (<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" rel="external" target="_blank">MIT</a>)</span></p>
<p>Rückgabewerte für den Funktionsaufruf werden innerhalb von <code>block</code> berechnet,
wo eine Reihe von Anweisungen interpretiert werden, weshalb <code>block</code> ursprünglich
keinen Rückgabewert hat. Im Prinzip könnte man <code>block</code> etwas zurück geben lassen,
was durch die möglicherweise tiefe Rekursion relativ umständlich werden kann.</p>
<p>An dieser Stelle kann man den Exceptions-Mechanismus <strong>missbrauchen</strong> und bei
der Auswertung eines <code>return</code> mit dem Ergebniswert direkt zum Funktionsaufruf
zurück springen. In Methoden, wo man einen neuen lokalen Kontext anlegt und
die globale <code>env</code>-Variable temporär damit ersetzt, muss man dann ebenfalls
mit <code>try/catch</code> arbeiten und im <code>finally</code>-Block die Umgebung zurücksetzen und
die Exception erneut werfen.</p>
<h2 id="native-funktionen">Native Funktionen</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Callable</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">call</span>(self, Interpreter i, List<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> a): <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Fun</span>(Callable): <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NativePrint</span>(Fun):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">call</span>(self, Interpreter i, List<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> a):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> o <span style="color:#f92672">in</span> a: print a  <span style="color:#75715e"># nur zur Demo, hier sinnvoller Code :-)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Im Interpreter (Initialisierung):</span>
</span></span><span style="display:flex;"><span>self<span style="color:#f92672">.</span>env<span style="color:#f92672">.</span>define(<span style="color:#e6db74">&#34;print&#34;</span>, NativePrint())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">funcCall</span>(self, AST t):
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#    prev = self.env;  self.env = Environment(fn.closure)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#    for i in range(args.size()): ...</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#    eval(fn.decl.block()); self.env = prev</span>
</span></span><span style="display:flex;"><span>    fn<span style="color:#f92672">.</span>call(self, args)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span></span></span></code></pre></div>
<p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="https://github.com/munificent/craftinginterpreters/blob/master/java/com/craftinginterpreters/lox/LoxCallable.java#L6" rel="external" target="_blank">LoxCallable.java</a> und <a href="https://github.com/munificent/craftinginterpreters/blob/master/java/com/craftinginterpreters/lox/LoxFunction.java#L6" rel="external" target="_blank">LoxFunction.java</a> by <a href="https://github.com/munificent" rel="external" target="_blank">Bob Nystrom</a> on Github.com (<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" rel="external" target="_blank">MIT</a>)</span></p>
<p>Normalerweise wird beim Interpretieren eines Funktionsaufrufs der
Funktionskörper (repräsentiert durch den entsprechenden AST-Teilbaum)
durch einen rekursiven Aufruf von <code>eval</code> ausgewertet.</p>
<p>Für native Funktionen, die im Interpreter eingebettet sind, klappt
das nicht mehr, da hier kein AST vorliegt.</p>
<p>Man erstellt ein neues Interface <code>Callable</code> mit der Hauptmethode <code>call()</code>
und leitet die frühere Klasse <code>Fun</code> davon ab: <code>class Fun(Callable)</code>.
Die Methode <code>funcCall()</code> des Interpreters ruft nun statt der <code>eval()</code>-Methode
die <code>call()</code>-Methode des Funktionsobjekts auf und übergibt den Interpreter
(== Zustand) und die Argumente. Die <code>call()</code>-Methode der Klasse <code>Fun</code> muss
nun ihrerseits im Normalfall den im Funktionsobjekt referenzierten AST-Teilbaum
des Funktionskörpers mit dem Aufruf von <code>eval()</code> interpretieren ...</p>
<p><a href="#R-image-dd2e95fddabcc594dc0e4093ceaa3b55" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/06-interpretation/astdriven-part2/callFun.png?width=auto&height=auto" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-dd2e95fddabcc594dc0e4093ceaa3b55"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/06-interpretation/astdriven-part2/callFun.png?width=auto&height=auto"></a></p>
<p>Für die nativen Funktionen leitet man einfach eine (anonyme) Klasse
ab und speichert sie unter dem gewünschten Namen im globalen Kontext
des Interpreters. Die <code>call()</code>-Methode wird dann entsprechend der
gewünschten Funktion implementiert, d.h. hier erfolgt kein weiteres
Auswerten des AST.</p>
<h2 id="klassen-und-instanzen-i">Klassen und Instanzen I</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>classDef : <span style="color:#e6db74">&#34;class&#34;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#34;{&#34;</span> funcDecl<span style="color:#f92672">*</span> <span style="color:#e6db74">&#34;}&#34;</span> ;</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">classDef</span>(self, AST t):
</span></span><span style="display:flex;"><span>    methods <span style="color:#f92672">=</span> HashMap<span style="color:#f92672">&lt;</span>String, Fun<span style="color:#f92672">&gt;</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> t<span style="color:#f92672">.</span>funcDecl():
</span></span><span style="display:flex;"><span>        fn <span style="color:#f92672">=</span> Fun(m, self<span style="color:#f92672">.</span>env)
</span></span><span style="display:flex;"><span>        methods[m<span style="color:#f92672">.</span>ID()<span style="color:#f92672">.</span>getText()] <span style="color:#f92672">=</span> fn
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    clazz <span style="color:#f92672">=</span> Clazz(methods)
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>env<span style="color:#f92672">.</span>define(t<span style="color:#f92672">.</span>ID()<span style="color:#f92672">.</span>getText(), clazz)</span></span></code></pre></div>
<p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="https://github.com/munificent/craftinginterpreters/blob/master/java/com/craftinginterpreters/lox/Interpreter.java#L115" rel="external" target="_blank">Interpreter.java</a> by <a href="https://github.com/munificent" rel="external" target="_blank">Bob Nystrom</a> on Github.com (<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" rel="external" target="_blank">MIT</a>)</span></p>
<p><strong>Anmerkung</strong>: In dieser Darstellung wird der Einfachheit halber nur auf Methoden eingegangen.
Für Attribute müssten ähnliche Konstrukte implementiert werden.</p>
<h2 id="klassen-und-instanzen-ii">Klassen und Instanzen II</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Clazz</span>(Callable):
</span></span><span style="display:flex;"><span>    __init__(self, Map<span style="color:#f92672">&lt;</span>String, Fun<span style="color:#f92672">&gt;</span> methods):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>methods <span style="color:#f92672">=</span> methods
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">call</span>(self, Interpreter i, List<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> a):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Instance(self)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findMethod</span>(self, String name):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>methods[name]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Instance</span>:
</span></span><span style="display:flex;"><span>    __init__(self, Clazz clazz):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>clazz <span style="color:#f92672">=</span> clazz
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get</span>(self, String name):
</span></span><span style="display:flex;"><span>        method <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>clazz<span style="color:#f92672">.</span>findMethod(name)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> method <span style="color:#f92672">!=</span> <span style="color:#66d9ef">None</span>: <span style="color:#66d9ef">return</span> method<span style="color:#f92672">.</span>bind(self)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">RuntimeError</span>(name, <span style="color:#e6db74">&#34;undefined method&#34;</span>)</span></span></code></pre></div>
<p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="https://github.com/munificent/craftinginterpreters/blob/master/java/com/craftinginterpreters/lox/LoxClass.java#L11" rel="external" target="_blank">LoxClass.java</a> und <a href="https://github.com/munificent/craftinginterpreters/blob/master/java/com/craftinginterpreters/lox/LoxInstance.java#L7" rel="external" target="_blank">LoxInstance.java</a> by <a href="https://github.com/munificent" rel="external" target="_blank">Bob Nystrom</a> on Github.com (<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" rel="external" target="_blank">MIT</a>)</span></p>
<p>Instanzen einer Klasse werden durch den funktionsartigen &quot;Aufruf&quot; der Klassen
angelegt (parameterloser Konstruktor). Eine Instanz hält die Attribute (hier
nicht gezeigt) und eine Referenz auf die Klasse, um später an die Methoden
heranzukommen.</p>
<h2 id="zugriff-auf-methoden-und-attribute">Zugriff auf Methoden (und Attribute)</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>getExpr : obj <span style="color:#e6db74">&#34;.&#34;</span> <span style="color:#66d9ef">ID</span> ;</span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">getExpr</span>(self, AST t):
</span></span><span style="display:flex;"><span>    obj <span style="color:#f92672">=</span> eval(t<span style="color:#f92672">.</span>obj())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> isinstance(obj, Instance):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ((Instance)obj)<span style="color:#f92672">.</span>get(t<span style="color:#f92672">.</span>ID()<span style="color:#f92672">.</span>getText())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">RuntimeError</span>(t<span style="color:#f92672">.</span>obj()<span style="color:#f92672">.</span>getText(), <span style="color:#e6db74">&#34;no object&#34;</span>)</span></span></code></pre></div>
<p>Beim Zugriff auf Attribute muss das Objekt im aktuellen Kontext evaluiert
werden. Falls es eine Instanz von <code>Instance</code> ist, wird auf das Feld per
interner Hash-Map zugriffen; sonst Exception.</p>
<h2 id="methoden-und-this-oder-self">Methoden und <em>this</em> oder <em>self</em></h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Fun</span>(Callable):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bind</span>(self, Instance i):
</span></span><span style="display:flex;"><span>        e <span style="color:#f92672">=</span> Environment(self<span style="color:#f92672">.</span>closure)
</span></span><span style="display:flex;"><span>        e<span style="color:#f92672">.</span>define(<span style="color:#e6db74">&#34;this&#34;</span>, i)
</span></span><span style="display:flex;"><span>        e<span style="color:#f92672">.</span>define(<span style="color:#e6db74">&#34;self&#34;</span>, i)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Fun(self<span style="color:#f92672">.</span>decl, e)</span></span></code></pre></div>
<p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="https://github.com/munificent/craftinginterpreters/blob/master/java/com/craftinginterpreters/lox/LoxFunction.java#L31" rel="external" target="_blank">LoxFunction.java</a> by <a href="https://github.com/munificent" rel="external" target="_blank">Bob Nystrom</a> on Github.com (<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" rel="external" target="_blank">MIT</a>)</span></p>
<p>Nach dem Interpretieren von Klassendefinitionen sind die Methoden in der Klasse
selbst gespeichert, wobei der jeweilige <code>closure</code> auf den Klassenkontext zeigt.</p>
<p>Beim Auflösen eines Methodenaufrufs wird die gefundene Methode an die
Instanz gebunden, d.h. es wird eine neue Funktion angelegt, deren <code>closure</code>
auf den Kontext der Instanz zeigt. Zusätzlich wird in diesem Kontext noch die
Variable &quot;<code>this</code>&quot; definiert, damit man damit auf die Instanz zugreifen kann.</p>
<p>In Python wird das in der Methodensignatur sichtbar: Der erste Parameter ist
eine Referenz auf die Instanz, auf der diese Methode ausgeführt werden soll ...</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>
<p>Interpreter simulieren die Programmausführung</p>
<ul>
<li>Namen und Symbole auflösen</li>
<li>Speicherbereiche simulieren</li>
<li>Code ausführen: Read-Eval-Loop</li>
</ul>
</li>
<li>
<p>Traversierung des AST: <code>eval(AST t)</code> als Visitor-Dispatcher</p>
</li>
<li>
<p>Scopes mit <code>Environment</code> (analog zu Symboltabellen)</p>
</li>
<li>
<p>Interpretation von Funktionen (Deklaration/Aufruf, native Funktionen)</p>
</li>
<li>
<p>Interpretation von Klassen und Instanzen</p>
</li>
</ul>


    



    



    

    <div class="box notices cstyle note">
  <div class="box-label">
    <i class="fas fa-puzzle-piece"></i> Challenges
  </div>
  <div class="box-content">
<ul>
<li>Wie interpretiert man Code?</li>
<li>Warum kann man die Werte nicht einfach in Symboltabellen ablegen?</li>
<li>Wie geht man mit Funktionen um? Warum? Kann man diese mehrfach aufrufen?</li>
<li>Wieso erzeugt man eine neue Environment mit der Closure in der Funktion?</li>
<li>Wie gehen native Funktionen?</li>
</ul>
<p>Betrachten Sie folgenden Code-Ausschnitt:</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">int</span> x) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> y<span style="color:#f92672">+</span>x;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#a6e22e">f</span>(x);</span></span></code></pre></div>
<ol>
<li>Geben Sie den AST an.</li>
<li>Stellen Sie die Strukturen der Symboltabelle dar.</li>
<li>Stellen Sie die Strukturen im Interpreter dar.</li>
</ol>
  </div>
</div>



    




    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-book-reader"></i> Quellen
  </div>
  <div class="box-content">
<ul> <li id='id_Grune2012'>[Grune2012] <strong>Modern Compiler Design</strong><br>Grune, D. und van, Reeuwijk, K. und Bal, H. E. und Jacobs, C. J. H. und Langendoen, K., Springer, 2012. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-4614-4698-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-4614-4698-9</a>.<br><em>Kapitel 6</em></li> <li id='id_Mogensen2017'>[Mogensen2017] <strong>Introduction to Compiler Design</strong><br>Mogensen, T., Springer, 2017. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-319-66966-3</a>. DOI <a href='https://doi.org/10.1007/978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-319-66966-3</a>.<br><em>Kapitel 4</em></li> <li id='id_Nystrom2021'>[Nystrom2021] <a href='https://github.com/munificent/craftinginterpreters' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>Crafting Interpreters</strong></a><br>Nystrom, R., Genever Benning, 2021. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-0-9905829-3-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-0-9905829-3-9</a>.<br><em>Kapitel Kapitel: A Tree-Walk Interpreter, insb. 10. Functions u. 12. Classes</em></li> <li id='id_Parr2010'>[Parr2010] <a href='https://learning.oreilly.com/library/view/language-implementation-patterns/9781680500097/' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>Language Implementation Patterns</strong></a><br>Parr, T., Pragmatic Bookshelf, 2010. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5645-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5645-6</a>.</li></ul>
  </div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin-left: 4rem; margin-right: 4rem; margin-top: 6rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

          </section>
        </div>
      </main>
    </div>
    <script src="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/js/clipboard.min.js?1736351933" defer></script>
    <script src="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/js/perfect-scrollbar.min.js?1736351933" defer></script>
    <script>
      function useMathJax( config ){
        window.MathJax = Object.assign( window.MathJax || {}, {
          tex: {
            inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
            displayMath: [['\\[', '\\]'], ['$$', '$$']], 
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/js/mathjax/tex-mml-chtml.js?1736351933"></script>
    <script src="/elearning/data/FH-Bielefeld/lm_data/lm_1603207/js/theme.js?1736351933" defer></script>
  </body>
</html>
